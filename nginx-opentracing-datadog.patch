diff --git a/datadog/config b/datadog/config
new file mode 100644
index 0000000..50752ab
--- /dev/null
+++ b/datadog/config
@@ -0,0 +1,15 @@
+ngx_addon_name=ngx_http_datadog_module
+ngx_module_type=HTTP
+ngx_module_name=$ngx_addon_name
+ngx_module_incs=
+ngx_module_deps=
+ngx_module_srcs=" \
+  $ngx_addon_dir/src/ngx_http_datadog_module.cpp \
+"
+ngx_module_libs=" \
+  -ldd_opentracing \
+"
+
+. auto/module
+
+DATADOG_NGX_SRCS="$ngx_module_srcs"
\ No newline at end of file
diff --git a/datadog/config.make b/datadog/config.make
new file mode 100644
index 0000000..2647cc1
--- /dev/null
+++ b/datadog/config.make
@@ -0,0 +1,6 @@
+# Patch the makefile to allow C++14 for our sources
+# (nginx doesn't expose CXXFLAGS)
+for src_file in $DATADOG_NGX_SRCS; do
+  obj_file="$NGX_OBJS/addon/src/`basename $src_file .cpp`.o"
+  echo "$obj_file : CFLAGS += --std=c++14" >> $NGX_MAKEFILE
+done
diff --git a/datadog/src/ngx_http_datadog_module.cpp b/datadog/src/ngx_http_datadog_module.cpp
new file mode 100644
index 0000000..83ee684
--- /dev/null
+++ b/datadog/src/ngx_http_datadog_module.cpp
@@ -0,0 +1,112 @@
+// NOTE: Unpolished module, still in incubation. When complete, will be
+// submitted to nginx-opentracing.
+
+#include <datadog/opentracing.h>
+#include <opentracing/tracer.h>
+#include <cstdlib>
+
+extern "C" {
+#include <nginx.h>
+#include <ngx_config.h>
+#include <ngx_core.h>
+#include <ngx_http.h>
+
+extern ngx_module_t ngx_http_datadog_module;
+}
+
+static inline std::string to_string(const ngx_str_t &str) {
+  return {str.data, str.data + str.len};
+}
+
+struct datadog_main_conf_t {
+  ngx_str_t agent_host;
+  ngx_str_t agent_port;
+  ngx_str_t service_name;
+  ngx_str_t span_name;
+};
+
+static ngx_int_t datadog_init_worker(ngx_cycle_t *cycle) {
+  auto main_conf = static_cast<datadog_main_conf_t *>(
+      ngx_http_cycle_get_module_main_conf(cycle, ngx_http_datadog_module));
+  datadog::opentracing::TracerOptions options;
+  if (main_conf->agent_host.data) {
+    options.agent_host = to_string(main_conf->agent_host);
+  }
+  if (main_conf->agent_port.data) {
+    // TODO(willgittoes-dd): Reasonable error handling. Here and like,
+    // everywhere else too.
+    try {
+      options.agent_port = std::stoi(to_string(main_conf->agent_port));
+    } catch (const std::invalid_argument &ia) {
+      ngx_log_error(NGX_LOG_ERR, cycle->log, 0,
+                    "Failed to parse datadog_agent_port");
+      return NGX_OK;
+    } catch (const std::out_of_range &oor) {
+      ngx_log_error(NGX_LOG_ERR, cycle->log, 0,
+                    "datadog_agent_port is out of range");
+      return NGX_OK;
+    }
+  }
+  if (main_conf->service_name.data) {
+    options.service = to_string(main_conf->service_name);
+  }
+  if (main_conf->span_name.data) {
+    options.span_name = to_string(main_conf->span_name);
+  }
+  auto tracer = datadog::opentracing::makeTracer(options);
+  if (!tracer) {
+    ngx_log_error(NGX_LOG_ERR, cycle->log, 0,
+                  "Failed to create Datadog tracer");
+    return NGX_OK;
+  }
+  opentracing::Tracer::InitGlobal(std::move(tracer));
+  return NGX_OK;
+}
+
+static void *create_datadog_main_conf(ngx_conf_t *conf) {
+  auto main_conf = static_cast<datadog_main_conf_t *>(
+      ngx_pcalloc(conf->pool, sizeof(datadog_main_conf_t)));
+  // Default initialize members.
+  *main_conf = datadog_main_conf_t();
+  if (!main_conf) return nullptr;
+  return main_conf;
+}
+
+static ngx_http_module_t datadog_module_ctx = {
+    nullptr,                  /* preconfiguration */
+    nullptr,                  /* postconfiguration */
+    create_datadog_main_conf, /* create main configuration */
+    nullptr,                  /* init main configuration */
+    nullptr,                  /* create server configuration */
+    nullptr,                  /* merge server configuration */
+    nullptr,                  /* create location configuration */
+    nullptr                   /* merge location configuration */
+};
+
+static ngx_command_t datadog_commands[] = {
+    {ngx_string("datadog_service_name"), NGX_HTTP_MAIN_CONF | NGX_CONF_TAKE1,
+     ngx_conf_set_str_slot, NGX_HTTP_MAIN_CONF_OFFSET,
+     offsetof(datadog_main_conf_t, service_name), nullptr},
+    {ngx_string("datadog_span_name"), NGX_HTTP_MAIN_CONF | NGX_CONF_TAKE1,
+     ngx_conf_set_str_slot, NGX_HTTP_MAIN_CONF_OFFSET,
+     offsetof(datadog_main_conf_t, span_name), nullptr},
+    {ngx_string("datadog_agent_host"), NGX_HTTP_MAIN_CONF | NGX_CONF_TAKE1,
+     ngx_conf_set_str_slot, NGX_HTTP_MAIN_CONF_OFFSET,
+     offsetof(datadog_main_conf_t, agent_host), nullptr},
+    {ngx_string("datadog_agent_port"), NGX_HTTP_MAIN_CONF | NGX_CONF_TAKE1,
+     ngx_conf_set_str_slot, NGX_HTTP_MAIN_CONF_OFFSET,
+     offsetof(datadog_main_conf_t, agent_port), nullptr}};
+
+ngx_module_t ngx_http_datadog_module = {
+    NGX_MODULE_V1,
+    &datadog_module_ctx, /* module context */
+    datadog_commands,    /* module directives */
+    NGX_HTTP_MODULE,     /* module type */
+    nullptr,             /* init master */
+    nullptr,             /* init module */
+    datadog_init_worker, /* init process */
+    nullptr,             /* init thread */
+    nullptr,             /* exit thread */
+    nullptr,             /* exit process */
+    nullptr,             /* exit master */
+    NGX_MODULE_V1_PADDING};
\ No newline at end of file
